import { createSlice } from "@reduxjs/toolkit";

const initialState = {
    movies: [{ id: 1, name: "Inception" }, { id: 2, name: "Interstellar" }, { id: 3, name: "Harry Potter" }],
};


/**
 * Redux Primitives
 *
 * This section defines the core building blocks used to manage state within this application:
 * - createSlice(): A Redux Toolkit function that accepts a name, initialState, and a reducers object to automatically generate action creators and types.
 * - Reducers: An object containing functions responsible for defining how the state is modified in response to specific actions.
 * - Action: A standard JavaScript object that carries a 'type' and an optional 'payload' to describe a state change.
 * - action.payload: The specific data passed to the reducer to facilitate state updates.
 * - action.type: A unique string identifier for the action being dispatched.
 */



/**
 * Movie Slice Definition
 *
 * Purpose:
 * Encapsulates the state logic for movies, bundling the initial state, reducers, and action creators into a single unit.
 *
 * How it works:
 * - 'createSlice' is a function that accepts a configuration object with a name, initial state, and reducer functions.
 * - Internal Immutability (Immer): Redux Toolkit uses the 'Immer' library, which allows us to write "mutating" syntax 
 *   (e.g., `state.movies.push`) in reducers like `addMovie`. Immer intercepts this and safely produces a new, immutable state. 
 *   This is why we don't need complex spread operators (...) for simple updates.
 * - `removeMovie` returns a new filtered array, which is also a valid way to update state.
 * - Automatic Generation: It auto-generates:
 *     1. Action Creators (e.g., `movieSlice.actions.addMovie`)
 *     2. Action Types (e.g., "movies/addMovie")
 *     3. The main Reducer function (`movieSlice.reducer`)
 *
 * Why we need it:
 * - Reduces Boilerplate: Removes the need for manual action types, action creators, and switch statements typical in older Redux.
 * - Readability: Keeps related logic (actions + reducers) in one file.
 * - Safety: Prevents accidental state mutation bugs via Immer.
 */
const movieSlice = createSlice({
    name: "movies",
    initialState,
    reducers: {
        addMovie: (state, action) => {
            const newMovie = {
                id: state.movies.length > 0 ? state.movies[state.movies.length - 1].id + 1 : 1,
                name: action.payload
            };
            state.movies.push(newMovie);
        },
        removeMovie: (state, action) => {
            state.movies = state.movies.filter(
                (movie) => movie.id !== action.payload
            );
        },
    },
});


/**
 * Action Creators
 *
 * Purpose:
 * These functions are automatically generated by `createSlice` based on the reducer names.
 * They return action objects with the correct type and payload for dispatching.
 *
 * Origin:
 * Redux Toolkit's `createSlice` maps the keys of the `reducers` object to these creators.
 *
 * Args:
 * @param {*} payload - The data to be passed to the corresponding reducer.
 *
 * Complexity:
 * - Time: O(1) - Constant time to create an action object.
 * - Space: O(1) - Constant space for the action object.
 *
 * Example:
 * dispatch(addMovie({ id: 1, title: "Inception" }));
 * dispatch(removeMovie(1));
 */
export const { addMovie, removeMovie } = movieSlice.actions;

/**
 * Slice Reducer
 *
 * Purpose:
 * The main reducer function that manages the state for this slice.
 *
 * Origin:
 * Automatically generated by `createSlice` by combining the defined reducer functions.
 *
 * Args:
 * @param {Object} state - The current state of the slice.
 * @param {Object} action - The action object containing type and payload.
 *
 * Complexity:
 * - Time: O(1) - Redux Toolkit uses an internal map for efficient reducer lookup.
 * - Space: O(1) - Returns a reference to the updated state.
 *
 * Example:
 * const rootReducer = combineReducers({
 *     movies: movieSlice.reducer,
 * });
 */
export default movieSlice.reducer;
